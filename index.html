<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Guess the State</title>
		<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
		<script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<div class="container">
			<header>
				<h1 id="title">Guess the Highlighted State</h1>
				<div class="score">
					<span id="score-label">Score</span>: <span id="score">0</span> |
					<span id="question-label">Question</span>: <span id="question-count">0</span>
				</div>
				<div class="lang-toggle" role="group" aria-label="Language">
					<button id="lang-en" class="active" type="button">English</button>
					<button id="lang-nl" type="button">Nederlands</button>
				</div>
				<div class="region-toggle" role="group" aria-label="Region">
					<button id="region-us" class="active" type="button">US states</button>
					<button id="region-eu" type="button">Europe countries</button>
				</div>
				<div class="quiz-toggle" role="group" aria-label="Question type">
					<button id="quiz-state" class="active" type="button">States</button>
					<button id="quiz-capital" type="button">Capitals</button>
				</div>
				<div class="mode-toggle" role="group" aria-label="Game mode">
					<button id="mode-choice" class="active" type="button">Multiple choice</button>
					<button id="mode-click" type="button">Click on map</button>
				</div>
			</header>

			<section class="card">
				<svg id="map" viewBox="0 0 975 610" aria-label="Map of the United States"></svg>
				<div class="question">
					<p id="prompt">Loading mapâ€¦</p>
					<div id="state-label" class="state-label" hidden>
						<button type="button" class="choice display-only"></button>
					</div>
					<div id="choices" class="choices"></div>
					<div class="feedback" id="feedback"></div>
				</div>
			</section>
		</div>

		<script>
			const mapSvg = d3.select("#map");
			const promptEl = document.getElementById("prompt");
			const stateLabelEl = document.getElementById("state-label");
			const stateLabelButton = stateLabelEl.querySelector("button");
			const choicesEl = document.getElementById("choices");
			const titleEl = document.getElementById("title");
			const scoreLabelEl = document.getElementById("score-label");
			const questionLabelEl = document.getElementById("question-label");
			const langEnBtn = document.getElementById("lang-en");
			const langNlBtn = document.getElementById("lang-nl");
			const regionUsBtn = document.getElementById("region-us");
			const regionEuBtn = document.getElementById("region-eu");
			const quizStateBtn = document.getElementById("quiz-state");
			const quizCapitalBtn = document.getElementById("quiz-capital");
			const modeChoiceBtn = document.getElementById("mode-choice");
			const modeClickBtn = document.getElementById("mode-click");
			const feedbackEl = document.getElementById("feedback");
			const scoreEl = document.getElementById("score");
			const questionCountEl = document.getElementById("question-count");

			let fipsToName = {};
			let capitalByState = {};
			let europeCapitalByCountry = {};
			let europeCountryNames = new Set();
			let i18nData = {};
			let locale = "en";

			let states = [];
			let remainingStates = [];
			let currentState = null;
			let score = 0;
			let questionCount = 0;
			let isLocked = false;
			let mode = "choice";
			let quizType = "state";
			let capitalsLayer = null;
			let region = "us";
			let microMarkersLayer = null;

			const normalize = (value) => value.trim().toLowerCase();

			const formatText = (text, vars = {}) =>
				Object.entries(vars).reduce(
					(result, [key, value]) =>
						result.replaceAll(`{${key}}`, String(value)),
					text
				);

			const t = (path, vars) => {
				const parts = path.split(".");
				const getValue = (obj) =>
					parts.reduce((acc, key) => (acc ? acc[key] : undefined), obj);
				const value =
					getValue(i18nData[locale]) ?? getValue(i18nData.en) ?? path;
				return typeof value === "string" ? formatText(value, vars) : value;
			};

			const regionLabel = () =>
				region === "us" ? t("ui.state") : t("ui.country");

			const localizeState = (name) => {
				const dict = region === "us" ? "states" : "countries";
				return (
					i18nData[locale]?.[dict]?.[name] ||
					i18nData.en?.[dict]?.[name] ||
					name
				);
			};

			const localizeCapital = (name) =>
				name
					? i18nData[locale]?.capitals?.[name] ||
						i18nData.en?.capitals?.[name] ||
						name
					: "";

			const isEuropeCountry = (name) => {
				const normalized = normalize(name);
				return (
					europeCountryNames.has(normalized) ||
					normalized.includes("russia") ||
					normalized.includes("bosnia")
				);
			};

			const loadStaticData = async () => {
				const [usData, euCapitals, euCountriesData, enTranslations, nlTranslations] =
					await Promise.all([
						fetch("data/us-states.json").then((response) => response.json()),
						fetch("data/europe-capitals.json").then((response) => response.json()),
						fetch("data/europe-countries.json").then((response) => response.json()),
						fetch("data/i18n/en.json").then((response) => response.json()),
						fetch("data/i18n/nl.json").then((response) => response.json())
					]);

				fipsToName = usData.fipsToName || {};
				capitalByState = usData.capitals || {};
				europeCapitalByCountry = euCapitals || {};
				const countriesList = Array.isArray(euCountriesData)
					? euCountriesData
					: euCountriesData?.countries || [];
				const microList = Array.isArray(euCountriesData)
					? []
					: euCountriesData?.microCountries || [];

				europeCountryNames = new Set(
					(countriesList || []).map((name) => String(name).toLowerCase())
				);
				microCountries = new Set(
					(microList || []).map((name) => String(name).toLowerCase())
				);
				i18nData = {
					en: enTranslations || {},
					nl: nlTranslations || {}
				};
				applyLanguage();
			};

			const europeBounds = {
				minLon: -25,
				maxLon: 50,
				minLat: 34,
				maxLat: 72
			};

			let microCountries = new Set();

			const isInEuropeBounds = ([lon, lat]) =>
				lon >= europeBounds.minLon &&
				lon <= europeBounds.maxLon &&
				lat >= europeBounds.minLat &&
				lat <= europeBounds.maxLat;

			const intersectsEuropeBounds = (bounds) => {
				if (!bounds) return false;
				const [[minLon, minLat], [maxLon, maxLat]] = bounds;
				return !(
					maxLon < europeBounds.minLon ||
					minLon > europeBounds.maxLon ||
					maxLat < europeBounds.minLat ||
					minLat > europeBounds.maxLat
				);
			};

			const filterOverseasFrance = (feature) => {
				if (normalize(feature.properties?.name || "") !== "france") {
					return feature;
				}
				if (!feature.geometry) return feature;
				if (feature.geometry.type === "Polygon") {
					const centroid = d3.geoCentroid(feature);
					return isInEuropeBounds(centroid) ? feature : null;
				}
				if (feature.geometry.type === "MultiPolygon") {
					const filteredPolygons = feature.geometry.coordinates.filter((polygon) => {
						const polygonFeature = {
							type: "Feature",
							properties: feature.properties,
							geometry: {
								type: "Polygon",
								coordinates: polygon
							}
						};
						const centroid = d3.geoCentroid(polygonFeature);
						return isInEuropeBounds(centroid);
					});
					if (!filteredPolygons.length) return null;
					return {
						...feature,
						geometry: {
							type: "MultiPolygon",
							coordinates: filteredPolygons
						}
					};
				}
				return feature;
			};

			const filterToEuropeBounds = (feature) => {
				if (!feature?.geometry) return feature;
				if (feature.geometry.type === "Polygon") {
					const bounds = d3.geoBounds(feature);
					return intersectsEuropeBounds(bounds) ? feature : null;
				}
				if (feature.geometry.type === "MultiPolygon") {
					const filteredPolygons = feature.geometry.coordinates.filter((polygon) => {
						const polygonFeature = {
							type: "Feature",
							properties: feature.properties,
							geometry: {
								type: "Polygon",
								coordinates: polygon
							}
						};
						const bounds = d3.geoBounds(polygonFeature);
						return intersectsEuropeBounds(bounds);
					});
					if (!filteredPolygons.length) return null;
					return {
						...feature,
						geometry: {
							type: "MultiPolygon",
							coordinates: filteredPolygons
						}
					};
				}
				return feature;
			};

			const filterSvalbard = (feature) => {
				if (normalize(feature.properties?.name || "") !== "norway") {
					return feature;
				}
				if (!feature.geometry) return feature;
				if (feature.geometry.type === "Polygon") {
					const centroid = d3.geoCentroid(feature);
					return isInEuropeBounds(centroid) ? feature : null;
				}
				if (feature.geometry.type === "MultiPolygon") {
					const filteredPolygons = feature.geometry.coordinates.filter((polygon) => {
						const polygonFeature = {
							type: "Feature",
							properties: feature.properties,
							geometry: {
								type: "Polygon",
								coordinates: polygon
							}
						};
						const centroid = d3.geoCentroid(polygonFeature);
						return isInEuropeBounds(centroid);
					});
					if (!filteredPolygons.length) return null;
					return {
						...feature,
						geometry: {
							type: "MultiPolygon",
							coordinates: filteredPolygons
						}
					};
				}
				return feature;
			};

			const shuffle = (array) => {
				for (let index = array.length - 1; index > 0; index -= 1) {
					const swapIndex = Math.floor(Math.random() * (index + 1));
					[array[index], array[swapIndex]] = [array[swapIndex], array[index]];
				}
				return array;
			};

			const getAnswerKey = (state) =>
				quizType === "capital"
					? state.properties.capital
					: state.properties.name;

			const getAnswerLabel = (state) =>
				quizType === "capital"
					? localizeCapital(state.properties.capital)
					: localizeState(state.properties.name);

			const hasCapital = (state) =>
				Boolean(state?.properties?.capital);

			const getEligibleStates = (list) =>
				quizType === "capital" ? list.filter(hasCapital) : list;

			const buildChoices = () => {
				if (!currentState) return [];
				const correctKey = getAnswerKey(currentState);
				const correctLabel = getAnswerLabel(currentState);
				if (!correctKey || !correctLabel) return [];

				const pool = getEligibleStates(states)
					.filter((state) => state !== currentState)
					.map((state) => ({
						key: getAnswerKey(state),
						label: getAnswerLabel(state)
					}))
					.filter((option) => option.key && option.label);

				const uniquePool = Array.from(
					new Map(pool.map((option) => [option.key, option])).values()
				);
				shuffle(uniquePool);
				const options = [
					{ key: correctKey, label: correctLabel },
					...uniquePool.slice(0, 4)
				];
				return shuffle(options);
			};

			const renderChoices = () => {
				if (mode !== "choice") {
					choicesEl.innerHTML = "";
					choicesEl.style.display = "none";
					return;
				}
				choicesEl.style.display = "grid";
				choicesEl.innerHTML = "";
				const options = buildChoices();
				options.forEach((option) => {
					const button = document.createElement("button");
					button.type = "button";
					button.className = "choice";
					button.textContent = option.label;
					button.addEventListener("click", () => checkAnswer(option.key));
					choicesEl.appendChild(button);
				});
			};

			const setInteraction = (enabled) => {
				choicesEl.querySelectorAll("button").forEach((button) => {
					button.disabled = !enabled;
				});
				mapSvg.style("pointer-events", enabled ? "auto" : "none");
				isLocked = !enabled;
			};

			const setMode = (nextMode) => {
				mode = nextMode;
				modeChoiceBtn.classList.toggle("active", mode === "choice");
				modeClickBtn.classList.toggle("active", mode === "click");
				resetGame();
			};

			const setQuizType = (nextType) => {
				quizType = nextType;
				quizStateBtn.classList.toggle("active", quizType === "state");
				quizCapitalBtn.classList.toggle("active", quizType === "capital");
				resetGame();
			};

			const setRegion = (nextRegion) => {
				region = nextRegion;
				regionUsBtn.classList.toggle("active", region === "us");
				regionEuBtn.classList.toggle("active", region === "eu");
				quizCapitalBtn.disabled = false;
				loadRegionData();
			};

			const applyLanguage = () => {
				titleEl.textContent = t("ui.title");
				scoreLabelEl.textContent = t("ui.score");
				questionLabelEl.textContent = t("ui.question");
				regionUsBtn.textContent = t("ui.regionUs");
				regionEuBtn.textContent = t("ui.regionEu");
				quizStateBtn.textContent = t("ui.quizState");
				quizCapitalBtn.textContent = t("ui.quizCapital");
				modeChoiceBtn.textContent = t("ui.modeChoice");
				modeClickBtn.textContent = t("ui.modeClick");
				langEnBtn.classList.toggle("active", locale === "en");
				langNlBtn.classList.toggle("active", locale === "nl");
				feedbackEl.textContent = "";
				updateQuestionUI();
				renderChoices();
			};

			const updateQuestionUI = () => {
				if (!currentState) {
					promptEl.textContent = t("ui.loading");
					return;
				}
				if (mode === "choice") {
					promptEl.textContent =
						quizType === "capital"
							? t("ui.promptCapital")
							: t("ui.promptState", { thing: regionLabel() });
					stateLabelEl.hidden = true;
					stateLabelEl.style.display = "none";
					stateLabelButton.textContent = "";
				} else {
					promptEl.textContent = "";
					stateLabelButton.textContent =
						quizType === "capital"
							? localizeCapital(currentState.properties.capital)
							: localizeState(currentState.properties.name);
					stateLabelEl.hidden = false;
					stateLabelEl.style.display = "flex";
				}
			};

			const resetGame = () => {
				score = 0;
				questionCount = 0;
				scoreEl.textContent = score;
				questionCountEl.textContent = questionCount;
				feedbackEl.textContent = "";
				stateLabelEl.hidden = mode !== "click";
				stateLabelEl.style.display = mode === "click" ? "flex" : "none";
				if (mode !== "click") {
					stateLabelButton.textContent = "";
				}
				remainingStates = getEligibleStates(states);
				mapSvg
					.selectAll("path")
					.classed("correct", false)
					.classed("wrong", false)
					.classed("highlight", false);
				if (capitalsLayer) {
					capitalsLayer
						.style(
							"display",
							quizType === "capital" ? "block" : "none"
						)
						.selectAll("circle")
						.classed("active", false);
				}
				if (microMarkersLayer) {
					microMarkersLayer
						.selectAll("circle")
						.classed("correct", false)
						.classed("wrong", false);
				}
				pickNextState();
			};

			const pickNextState = () => {
				if (!states.length) return;
				const eligibleRemaining = getEligibleStates(remainingStates);
				if (!eligibleRemaining.length) {
					promptEl.textContent = t("ui.allAnswered");
					setInteraction(false);
					return;
				}
				const index = Math.floor(Math.random() * eligibleRemaining.length);
				const next = eligibleRemaining.splice(index, 1)[0];
				remainingStates = eligibleRemaining;
				currentState = next;
				questionCount += 1;
				questionCountEl.textContent = questionCount;
				updateQuestionUI();
				renderChoices();
				setInteraction(true);

				mapSvg
					.selectAll("path")
					.classed(
						"highlight",
						(d) => mode === "choice" && quizType === "state" && d === currentState
					);

				if (capitalsLayer) {
					capitalsLayer.style(
						"display",
						quizType === "capital" ? "block" : "none"
					);
					capitalsLayer
						.selectAll("circle")
						.classed(
							"active",
							(d) =>
								quizType === "capital" &&
								mode === "choice" &&
								d.state === currentState
						);
				}
				if (microMarkersLayer) {
					microMarkersLayer
						.selectAll("circle")
						.classed(
							"highlight",
							(d) => mode === "choice" && quizType === "state" && d.state === currentState
						);
				}
			};

			const checkAnswer = (selected) => {
				if (!currentState) return;
				if (isLocked) return;
				setInteraction(false);
				const userAnswer = selected || "";
				const correctAnswer = getAnswerKey(currentState);
				const targetPath = mapSvg
					.selectAll("path")
					.filter((d) => d === currentState);
				const targetCapital =
					quizType === "capital"
						? capitalsLayer
							?.selectAll("circle")
							.filter((d) => d.state === currentState)
						: null;
				const targetMicro =
					microMarkersLayer
						?.selectAll("circle")
						.filter((d) => d.state === currentState) || null;

				if (userAnswer === correctAnswer) {
					score += 1;
					scoreEl.textContent = score;
					feedbackEl.textContent = t("ui.correct");
					targetPath.classed("correct", true).classed("wrong", false);
					targetCapital?.classed("correct", true).classed("wrong", false);
					targetMicro?.classed("correct", true).classed("wrong", false);
					setTimeout(() => pickNextState(), 700);
				} else {
					const displayState = localizeState(currentState.properties.name);
					const displayCapital = localizeCapital(currentState.properties.capital);
					feedbackEl.textContent =
						quizType === "capital"
							? t("ui.notQuiteCapital", {
								capital: displayCapital,
								state: displayState
							})
							: t("ui.notQuiteState", { state: displayState });
					targetPath.classed("wrong", true).classed("correct", false);
					targetCapital?.classed("wrong", true).classed("correct", false);
					targetMicro?.classed("wrong", true).classed("correct", false);
					setTimeout(() => pickNextState(), 900);
				}
			};

			const checkMapAnswer = (clickedState) => {
				if (!currentState) return;
				if (isLocked || mode !== "click") return;
				setInteraction(false);
				const clickedName = clickedState.properties.name;
				const correctName = currentState.properties.name;
				const targetPath = mapSvg
					.selectAll("path")
					.filter((d) => d === currentState);
				const targetCapital =
					quizType === "capital"
						? capitalsLayer
							?.selectAll("circle")
							.filter((d) => d.state === currentState)
						: null;
				const targetMicro =
					microMarkersLayer
						?.selectAll("circle")
						.filter((d) => d.state === currentState) || null;

				if (clickedState === currentState) {
					score += 1;
					scoreEl.textContent = score;
					feedbackEl.textContent = t("ui.correct");
					targetPath.classed("correct", true).classed("wrong", false);
					targetCapital?.classed("correct", true).classed("wrong", false);
					targetMicro?.classed("correct", true).classed("wrong", false);
					setTimeout(() => pickNextState(), 700);
				} else {
					const displayClicked = localizeState(clickedName);
					const displayCorrect = localizeState(correctName);
					const displayCapital = localizeCapital(currentState.properties.capital);
					feedbackEl.textContent =
						quizType === "capital"
							? t("ui.wrongClickCapital", {
								clicked: displayClicked,
								state: displayCorrect,
								capital: displayCapital
							})
							: t("ui.wrongClickState", {
								clicked: displayClicked,
								state: displayCorrect
							});
					targetPath.classed("wrong", true).classed("correct", false);
					targetCapital?.classed("wrong", true).classed("correct", false);
					targetMicro?.classed("wrong", true).classed("correct", false);
					setTimeout(() => pickNextState(), 900);
				}
			};


			const buildMap = (features, projection) => {
				const path = d3.geoPath(projection);

				mapSvg.selectAll("*").remove();
				capitalsLayer = null;
				microMarkersLayer = null;

				remainingStates = [...features];
				states = features;

				mapSvg
					.append("g")
					.attr("class", "states")
					.selectAll("path")
					.data(states)
					.join("path")
					.attr("d", path)
					.attr("aria-label", (d) => d.properties.name)
					.on("click", (event, d) => checkMapAnswer(d));

				const capitalPoints = states
					.map((state) => {
						if (!state.properties.capitalCoords) return null;
						const projected = projection(state.properties.capitalCoords);
						if (!projected) return null;
						return { state, coords: projected };
					})
					.filter(Boolean);

				if (capitalPoints.length) {
					capitalsLayer = mapSvg.append("g").attr("class", "capitals");
					capitalsLayer
						.selectAll("circle")
						.data(capitalPoints)
						.join("circle")
						.attr("r", 4)
						.attr("cx", (d) => d.coords[0])
						.attr("cy", (d) => d.coords[1])
						.on("click", (event, d) => checkMapAnswer(d.state));
				}

				if (region === "eu") {
					const microPoints = capitalPoints.filter((point) =>
						microCountries.has(normalize(point.state.properties.name))
					);

					if (microPoints.length) {
						microMarkersLayer = mapSvg
							.append("g")
							.attr("class", "micro-markers");
						microMarkersLayer
							.selectAll("circle")
							.data(microPoints)
							.join("circle")
							.attr("r", 7)
							.attr("cx", (d) => d.coords[0])
							.attr("cy", (d) => d.coords[1])
							.on("click", (event, d) => checkMapAnswer(d.state));
					}
				}

				pickNextState();
			};

			const loadRegionData = () => {
				promptEl.textContent = t("ui.loading");
				if (region === "us") {
					fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json")
						.then((response) => response.json())
						.then((topology) => {
							const geoData = topojson.feature(
								topology,
								topology.objects.states
							);
							const projection = d3.geoAlbersUsa().fitSize(
								[975, 610],
								geoData
							);

							const features = geoData.features
								.map((feature) => {
									const fips = String(feature.id).padStart(2, "0");
									const stateName = fipsToName[fips] || "Unknown";
									const capitalInfo = capitalByState[stateName];
									return {
										...feature,
										properties: {
											...feature.properties,
											name: stateName,
											capital: capitalInfo?.capital || null,
											capitalCoords: capitalInfo
												? [capitalInfo.lon, capitalInfo.lat]
												: null
										}
									};
								})
								.filter((feature) => feature.properties.name !== "Unknown");

							buildMap(features, projection);
						})
						.catch(() => {
							promptEl.textContent = t("ui.loadFail");
						});
					return;
				}

				fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json")
					.then((response) => response.json())
					.then((topology) => {
						const geoData = topojson.feature(
							topology,
							topology.objects.countries
						);
						const europeFeatures = geoData.features
							.map((feature) => {
								const name = feature.properties?.name || "";
								const capitalInfo = europeCapitalByCountry[name];
								return {
									...feature,
									properties: {
										...feature.properties,
										name,
										capital: capitalInfo?.capital || null,
										capitalCoords: capitalInfo
											? [capitalInfo.lon, capitalInfo.lat]
											: null
									}
								};
							})
							.filter((feature) => isEuropeCountry(feature.properties.name))
							.map(filterOverseasFrance)
							.map(filterSvalbard)
							.map(filterToEuropeBounds)
							.filter(Boolean);

						const projection = d3.geoMercator().fitSize(
							[975, 610],
							{ type: "FeatureCollection", features: europeFeatures }
						);

						buildMap(europeFeatures, projection);
					})
					.catch(() => {
						promptEl.textContent = t("ui.loadFail");
					});
			};

			quizStateBtn.addEventListener("click", () => setQuizType("state"));
			quizCapitalBtn.addEventListener("click", () => setQuizType("capital"));
			modeChoiceBtn.addEventListener("click", () => setMode("choice"));
			modeClickBtn.addEventListener("click", () => setMode("click"));
			regionUsBtn.addEventListener("click", () => setRegion("us"));
			regionEuBtn.addEventListener("click", () => setRegion("eu"));
			langEnBtn.addEventListener("click", () => {
				locale = "en";
				applyLanguage();
			});
			langNlBtn.addEventListener("click", () => {
				locale = "nl";
				applyLanguage();
			});

			loadStaticData()
				.then(() => loadRegionData())
				.catch(() => {
					promptEl.textContent = t("ui.loadLocalFail");
				});
		</script>
	</body>
</html>
