<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Guess the State</title>
		<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
		<script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<div class="container">
			<header>
				<h1>Guess the Highlighted State</h1>
				<div class="score">Score: <span id="score">0</span> | Question: <span id="question-count">0</span></div>
				<div class="region-toggle" role="group" aria-label="Region">
					<button id="region-us" class="active" type="button">US states</button>
					<button id="region-eu" type="button">Europe countries</button>
				</div>
				<div class="quiz-toggle" role="group" aria-label="Question type">
					<button id="quiz-state" class="active" type="button">States</button>
					<button id="quiz-capital" type="button">Capitals</button>
				</div>
				<div class="mode-toggle" role="group" aria-label="Game mode">
					<button id="mode-choice" class="active" type="button">Multiple choice</button>
					<button id="mode-click" type="button">Click on map</button>
				</div>
			</header>

			<section class="card">
				<svg id="map" viewBox="0 0 975 610" aria-label="Map of the United States"></svg>
				<div class="question">
					<p id="prompt">Loading map…</p>
					<div id="state-label" class="state-label" hidden>
						<button type="button" class="choice display-only"></button>
					</div>
					<div id="choices" class="choices"></div>
					<div class="feedback" id="feedback"></div>
				</div>
			</section>
		</div>

		<script>
			const mapSvg = d3.select("#map");
			const promptEl = document.getElementById("prompt");
			const stateLabelEl = document.getElementById("state-label");
			const stateLabelButton = stateLabelEl.querySelector("button");
			const choicesEl = document.getElementById("choices");
			const regionUsBtn = document.getElementById("region-us");
			const regionEuBtn = document.getElementById("region-eu");
			const quizStateBtn = document.getElementById("quiz-state");
			const quizCapitalBtn = document.getElementById("quiz-capital");
			const modeChoiceBtn = document.getElementById("mode-choice");
			const modeClickBtn = document.getElementById("mode-click");
			const feedbackEl = document.getElementById("feedback");
			const scoreEl = document.getElementById("score");
			const questionCountEl = document.getElementById("question-count");

			const fipsToName = {
				"01": "Alabama",
				"02": "Alaska",
				"04": "Arizona",
				"05": "Arkansas",
				"06": "California",
				"08": "Colorado",
				"09": "Connecticut",
				"10": "Delaware",
				"11": "District of Columbia",
				"12": "Florida",
				"13": "Georgia",
				"15": "Hawaii",
				"16": "Idaho",
				"17": "Illinois",
				"18": "Indiana",
				"19": "Iowa",
				"20": "Kansas",
				"21": "Kentucky",
				"22": "Louisiana",
				"23": "Maine",
				"24": "Maryland",
				"25": "Massachusetts",
				"26": "Michigan",
				"27": "Minnesota",
				"28": "Mississippi",
				"29": "Missouri",
				"30": "Montana",
				"31": "Nebraska",
				"32": "Nevada",
				"33": "New Hampshire",
				"34": "New Jersey",
				"35": "New Mexico",
				"36": "New York",
				"37": "North Carolina",
				"38": "North Dakota",
				"39": "Ohio",
				"40": "Oklahoma",
				"41": "Oregon",
				"42": "Pennsylvania",
				"44": "Rhode Island",
				"45": "South Carolina",
				"46": "South Dakota",
				"47": "Tennessee",
				"48": "Texas",
				"49": "Utah",
				"50": "Vermont",
				"51": "Virginia",
				"53": "Washington",
				"54": "West Virginia",
				"55": "Wisconsin",
				"56": "Wyoming"
			};

			const capitalByState = {
				Alabama: { capital: "Montgomery", lat: 32.377716, lon: -86.300568 },
				Alaska: { capital: "Juneau", lat: 58.301598, lon: -134.420212 },
				Arizona: { capital: "Phoenix", lat: 33.448143, lon: -112.096962 },
				Arkansas: { capital: "Little Rock", lat: 34.746613, lon: -92.288986 },
				California: { capital: "Sacramento", lat: 38.576668, lon: -121.493629 },
				Colorado: { capital: "Denver", lat: 39.739227, lon: -104.984856 },
				Connecticut: { capital: "Hartford", lat: 41.764046, lon: -72.682198 },
				Delaware: { capital: "Dover", lat: 39.157307, lon: -75.519722 },
				"District of Columbia": { capital: "Washington", lat: 38.9072, lon: -77.0369 },
				Florida: { capital: "Tallahassee", lat: 30.438118, lon: -84.281296 },
				Georgia: { capital: "Atlanta", lat: 33.749027, lon: -84.388229 },
				Hawaii: { capital: "Honolulu", lat: 21.307442, lon: -157.857376 },
				Idaho: { capital: "Boise", lat: 43.617775, lon: -116.199722 },
				Illinois: { capital: "Springfield", lat: 39.798363, lon: -89.654961 },
				Indiana: { capital: "Indianapolis", lat: 39.768623, lon: -86.162643 },
				Iowa: { capital: "Des Moines", lat: 41.591087, lon: -93.603729 },
				Kansas: { capital: "Topeka", lat: 39.048191, lon: -95.677956 },
				Kentucky: { capital: "Frankfort", lat: 38.186722, lon: -84.875374 },
				Louisiana: { capital: "Baton Rouge", lat: 30.457069, lon: -91.187393 },
				Maine: { capital: "Augusta", lat: 44.307167, lon: -69.781693 },
				Maryland: { capital: "Annapolis", lat: 38.978764, lon: -76.490936 },
				Massachusetts: { capital: "Boston", lat: 42.358162, lon: -71.063698 },
				Michigan: { capital: "Lansing", lat: 42.733635, lon: -84.555328 },
				Minnesota: { capital: "Saint Paul", lat: 44.955097, lon: -93.102211 },
				Mississippi: { capital: "Jackson", lat: 32.303848, lon: -90.182106 },
				Missouri: { capital: "Jefferson City", lat: 38.579201, lon: -92.172935 },
				Montana: { capital: "Helena", lat: 46.585709, lon: -112.018417 },
				Nebraska: { capital: "Lincoln", lat: 40.808075, lon: -96.699654 },
				Nevada: { capital: "Carson City", lat: 39.163914, lon: -119.766121 },
				"New Hampshire": { capital: "Concord", lat: 43.206898, lon: -71.537994 },
				"New Jersey": { capital: "Trenton", lat: 40.22039, lon: -74.7643 },
				"New Mexico": { capital: "Santa Fe", lat: 35.68224, lon: -105.939728 },
				"New York": { capital: "Albany", lat: 42.652843, lon: -73.757874 },
				"North Carolina": { capital: "Raleigh", lat: 35.78043, lon: -78.639099 },
				"North Dakota": { capital: "Bismarck", lat: 46.82085, lon: -100.783318 },
				Ohio: { capital: "Columbus", lat: 39.961346, lon: -82.999069 },
				Oklahoma: { capital: "Oklahoma City", lat: 35.492207, lon: -97.503342 },
				Oregon: { capital: "Salem", lat: 44.938461, lon: -123.030403 },
				Pennsylvania: { capital: "Harrisburg", lat: 40.264378, lon: -76.883598 },
				"Rhode Island": { capital: "Providence", lat: 41.830914, lon: -71.414963 },
				"South Carolina": { capital: "Columbia", lat: 34.000343, lon: -81.033211 },
				"South Dakota": { capital: "Pierre", lat: 44.367031, lon: -100.346405 },
				Tennessee: { capital: "Nashville", lat: 36.16581, lon: -86.784241 },
				Texas: { capital: "Austin", lat: 30.27467, lon: -97.740349 },
				Utah: { capital: "Salt Lake City", lat: 40.777477, lon: -111.888237 },
				Vermont: { capital: "Montpelier", lat: 44.262436, lon: -72.580536 },
				Virginia: { capital: "Richmond", lat: 37.538857, lon: -77.43364 },
				Washington: { capital: "Olympia", lat: 47.035805, lon: -122.905014 },
				"West Virginia": { capital: "Charleston", lat: 38.336246, lon: -81.612328 },
				Wisconsin: { capital: "Madison", lat: 43.074684, lon: -89.384445 },
				Wyoming: { capital: "Cheyenne", lat: 41.140259, lon: -104.820236 }
			};

			const europeCapitalByCountry = {
				Albania: { capital: "Tirana", lat: 41.3275, lon: 19.8187 },
				Andorra: { capital: "Andorra la Vella", lat: 42.5063, lon: 1.5218 },
				Armenia: { capital: "Yerevan", lat: 40.1872, lon: 44.5152 },
				Austria: { capital: "Vienna", lat: 48.2082, lon: 16.3738 },
				Azerbaijan: { capital: "Baku", lat: 40.4093, lon: 49.8671 },
				Belarus: { capital: "Minsk", lat: 53.9006, lon: 27.559 },
				Belgium: { capital: "Brussels", lat: 50.8503, lon: 4.3517 },
				"Bosnia and Herzegovina": { capital: "Sarajevo", lat: 43.8563, lon: 18.4131 },
				Bulgaria: { capital: "Sofia", lat: 42.6977, lon: 23.3219 },
				Croatia: { capital: "Zagreb", lat: 45.815, lon: 15.9819 },
				Cyprus: { capital: "Nicosia", lat: 35.1856, lon: 33.3823 },
				Czechia: { capital: "Prague", lat: 50.0755, lon: 14.4378 },
				Denmark: { capital: "Copenhagen", lat: 55.6761, lon: 12.5683 },
				Estonia: { capital: "Tallinn", lat: 59.437, lon: 24.7536 },
				Finland: { capital: "Helsinki", lat: 60.1699, lon: 24.9384 },
				France: { capital: "Paris", lat: 48.8566, lon: 2.3522 },
				Georgia: { capital: "Tbilisi", lat: 41.7151, lon: 44.8271 },
				Germany: { capital: "Berlin", lat: 52.52, lon: 13.405 },
				Greece: { capital: "Athens", lat: 37.9838, lon: 23.7275 },
				Hungary: { capital: "Budapest", lat: 47.4979, lon: 19.0402 },
				Iceland: { capital: "Reykjavik", lat: 64.1466, lon: -21.9426 },
				Ireland: { capital: "Dublin", lat: 53.3498, lon: -6.2603 },
				Italy: { capital: "Rome", lat: 41.9028, lon: 12.4964 },
				Kosovo: { capital: "Pristina", lat: 42.6629, lon: 21.1655 },
				Latvia: { capital: "Riga", lat: 56.9496, lon: 24.1052 },
				Liechtenstein: { capital: "Vaduz", lat: 47.141, lon: 9.5209 },
				Lithuania: { capital: "Vilnius", lat: 54.6872, lon: 25.2797 },
				Luxembourg: { capital: "Luxembourg", lat: 49.6116, lon: 6.1319 },
				Malta: { capital: "Valletta", lat: 35.8978, lon: 14.5125 },
				Moldova: { capital: "Chisinau", lat: 47.0105, lon: 28.8638 },
				Monaco: { capital: "Monaco", lat: 43.7384, lon: 7.4246 },
				Montenegro: { capital: "Podgorica", lat: 42.4304, lon: 19.2594 },
				Netherlands: { capital: "Amsterdam", lat: 52.3676, lon: 4.9041 },
				"North Macedonia": { capital: "Skopje", lat: 41.9981, lon: 21.4254 },
				Norway: { capital: "Oslo", lat: 59.9139, lon: 10.7522 },
				Poland: { capital: "Warsaw", lat: 52.2297, lon: 21.0122 },
				Portugal: { capital: "Lisbon", lat: 38.7223, lon: -9.1393 },
				Romania: { capital: "Bucharest", lat: 44.4268, lon: 26.1025 },
				Russia: { capital: "Moscow", lat: 55.7558, lon: 37.6173 },
				"San Marino": { capital: "San Marino", lat: 43.9424, lon: 12.4578 },
				Serbia: { capital: "Belgrade", lat: 44.7866, lon: 20.4489 },
				Slovakia: { capital: "Bratislava", lat: 48.1486, lon: 17.1077 },
				Slovenia: { capital: "Ljubljana", lat: 46.0569, lon: 14.5058 },
				Spain: { capital: "Madrid", lat: 40.4168, lon: -3.7038 },
				Sweden: { capital: "Stockholm", lat: 59.3293, lon: 18.0686 },
				Switzerland: { capital: "Bern", lat: 46.948, lon: 7.4474 },
				Turkey: { capital: "Ankara", lat: 39.9334, lon: 32.8597 },
				Ukraine: { capital: "Kyiv", lat: 50.4501, lon: 30.5234 },
				"United Kingdom": { capital: "London", lat: 51.5074, lon: -0.1278 },
				"Vatican City": { capital: "Vatican City", lat: 41.9029, lon: 12.4534 }
			};

			const europeCountryNames = new Set(
				[
					"albania",
					"andorra",
					"armenia",
					"austria",
					"azerbaijan",
					"belarus",
					"belgium",
					"bosnia and herzegovina",
					"bosnia and herzeg.",
					"bulgaria",
					"croatia",
					"cyprus",
					"czechia",
					"czech republic",
					"denmark",
					"estonia",
					"finland",
					"france",
					"georgia",
					"germany",
					"greece",
					"hungary",
					"iceland",
					"ireland",
					"italy",
					"kosovo",
					"latvia",
					"liechtenstein",
					"lithuania",
					"luxembourg",
					"malta",
					"moldova",
					"republic of moldova",
					"monaco",
					"montenegro",
					"netherlands",
					"north macedonia",
					"macedonia",
					"norway",
					"poland",
					"portugal",
					"romania",
					
					"san marino",
					"russia",
					"russian federation",
					"serbia",
					"republic of serbia",
					"slovakia",
					"slovenia",
					"spain",
					"sweden",
					"switzerland",
					"turkey",
					"ukraine",
					"united kingdom",
					"great britain",
					"vatican",
					"holy see",
					"vatican city"
				].map((name) => name.toLowerCase())
			);

			let states = [];
			let remainingStates = [];
			let currentState = null;
			let score = 0;
			let questionCount = 0;
			let isLocked = false;
			let mode = "choice";
			let quizType = "state";
			let capitalsLayer = null;
			let region = "us";

			const normalize = (value) => value.trim().toLowerCase();

			const regionLabel = () => (region === "us" ? "state" : "country");

			const isEuropeCountry = (name) => {
				const normalized = normalize(name);
				return (
					europeCountryNames.has(normalized) ||
					normalized.includes("russia") ||
					normalized.includes("bosnia")
				);
			};

			const europeBounds = {
				minLon: -25,
				maxLon: 50,
				minLat: 34,
				maxLat: 72
			};

			const isInEuropeBounds = ([lon, lat]) =>
				lon >= europeBounds.minLon &&
				lon <= europeBounds.maxLon &&
				lat >= europeBounds.minLat &&
				lat <= europeBounds.maxLat;

			const intersectsEuropeBounds = (bounds) => {
				if (!bounds) return false;
				const [[minLon, minLat], [maxLon, maxLat]] = bounds;
				return !(
					maxLon < europeBounds.minLon ||
					minLon > europeBounds.maxLon ||
					maxLat < europeBounds.minLat ||
					minLat > europeBounds.maxLat
				);
			};

			const filterOverseasFrance = (feature) => {
				if (normalize(feature.properties?.name || "") !== "france") {
					return feature;
				}
				if (!feature.geometry) return feature;
				if (feature.geometry.type === "Polygon") {
					const centroid = d3.geoCentroid(feature);
					return isInEuropeBounds(centroid) ? feature : null;
				}
				if (feature.geometry.type === "MultiPolygon") {
					const filteredPolygons = feature.geometry.coordinates.filter((polygon) => {
						const polygonFeature = {
							type: "Feature",
							properties: feature.properties,
							geometry: {
								type: "Polygon",
								coordinates: polygon
							}
						};
						const centroid = d3.geoCentroid(polygonFeature);
						return isInEuropeBounds(centroid);
					});
					if (!filteredPolygons.length) return null;
					return {
						...feature,
						geometry: {
							type: "MultiPolygon",
							coordinates: filteredPolygons
						}
					};
				}
				return feature;
			};

			const filterToEuropeBounds = (feature) => {
				if (!feature?.geometry) return feature;
				if (feature.geometry.type === "Polygon") {
					const bounds = d3.geoBounds(feature);
					return intersectsEuropeBounds(bounds) ? feature : null;
				}
				if (feature.geometry.type === "MultiPolygon") {
					const filteredPolygons = feature.geometry.coordinates.filter((polygon) => {
						const polygonFeature = {
							type: "Feature",
							properties: feature.properties,
							geometry: {
								type: "Polygon",
								coordinates: polygon
							}
						};
						const bounds = d3.geoBounds(polygonFeature);
						return intersectsEuropeBounds(bounds);
					});
					if (!filteredPolygons.length) return null;
					return {
						...feature,
						geometry: {
							type: "MultiPolygon",
							coordinates: filteredPolygons
						}
					};
				}
				return feature;
			};

			const filterSvalbard = (feature) => {
				if (normalize(feature.properties?.name || "") !== "norway") {
					return feature;
				}
				if (!feature.geometry) return feature;
				if (feature.geometry.type === "Polygon") {
					const centroid = d3.geoCentroid(feature);
					return isInEuropeBounds(centroid) ? feature : null;
				}
				if (feature.geometry.type === "MultiPolygon") {
					const filteredPolygons = feature.geometry.coordinates.filter((polygon) => {
						const polygonFeature = {
							type: "Feature",
							properties: feature.properties,
							geometry: {
								type: "Polygon",
								coordinates: polygon
							}
						};
						const centroid = d3.geoCentroid(polygonFeature);
						return isInEuropeBounds(centroid);
					});
					if (!filteredPolygons.length) return null;
					return {
						...feature,
						geometry: {
							type: "MultiPolygon",
							coordinates: filteredPolygons
						}
					};
				}
				return feature;
			};

			const shuffle = (array) => {
				for (let index = array.length - 1; index > 0; index -= 1) {
					const swapIndex = Math.floor(Math.random() * (index + 1));
					[array[index], array[swapIndex]] = [array[swapIndex], array[index]];
				}
				return array;
			};

			const getAnswerLabel = (state) =>
				quizType === "capital"
					? state.properties.capital
					: state.properties.name;

			const hasCapital = (state) =>
				Boolean(state?.properties?.capital);

			const getEligibleStates = (list) =>
				quizType === "capital" ? list.filter(hasCapital) : list;

			const buildChoices = () => {
				if (!currentState) return [];
				const correctName = getAnswerLabel(currentState);
				const pool = getEligibleStates(states)
					.filter((state) => state !== currentState)
					.map((state) => getAnswerLabel(state))
					.filter(Boolean);
				if (!correctName) return [];
				shuffle(pool);
				const options = [correctName, ...pool.slice(0, 4)];
				return shuffle(options);
			};

			const renderChoices = () => {
				if (mode !== "choice") {
					choicesEl.innerHTML = "";
					choicesEl.style.display = "none";
					return;
				}
				choicesEl.style.display = "grid";
				choicesEl.innerHTML = "";
				const options = buildChoices();
				options.forEach((option) => {
					const button = document.createElement("button");
					button.type = "button";
					button.className = "choice";
					button.textContent = option;
					button.addEventListener("click", () => checkAnswer(option));
					choicesEl.appendChild(button);
				});
			};

			const setInteraction = (enabled) => {
				choicesEl.querySelectorAll("button").forEach((button) => {
					button.disabled = !enabled;
				});
				mapSvg.style("pointer-events", enabled ? "auto" : "none");
				isLocked = !enabled;
			};

			const setMode = (nextMode) => {
				mode = nextMode;
				modeChoiceBtn.classList.toggle("active", mode === "choice");
				modeClickBtn.classList.toggle("active", mode === "click");
				resetGame();
			};

			const setQuizType = (nextType) => {
				quizType = nextType;
				quizStateBtn.classList.toggle("active", quizType === "state");
				quizCapitalBtn.classList.toggle("active", quizType === "capital");
				resetGame();
			};

			const setRegion = (nextRegion) => {
				region = nextRegion;
				regionUsBtn.classList.toggle("active", region === "us");
				regionEuBtn.classList.toggle("active", region === "eu");
				quizCapitalBtn.disabled = false;
				loadRegionData();
			};

			const resetGame = () => {
				score = 0;
				questionCount = 0;
				scoreEl.textContent = score;
				questionCountEl.textContent = questionCount;
				feedbackEl.textContent = "";
				stateLabelEl.hidden = mode !== "click";
				stateLabelEl.style.display = mode === "click" ? "flex" : "none";
				if (mode !== "click") {
					stateLabelButton.textContent = "";
				}
				remainingStates = getEligibleStates(states);
				mapSvg
					.selectAll("path")
					.classed("correct", false)
					.classed("wrong", false)
					.classed("highlight", false);
				if (capitalsLayer) {
					capitalsLayer
						.style(
							"display",
							quizType === "capital" && mode === "choice" ? "block" : "none"
						)
						.selectAll("circle")
						.classed("active", false);
				}
				pickNextState();
			};

			const pickNextState = () => {
				if (!states.length) return;
				const eligibleRemaining = getEligibleStates(remainingStates);
				if (!eligibleRemaining.length) {
					promptEl.textContent = "All states answered!";
					setInteraction(false);
					return;
				}
				const index = Math.floor(Math.random() * eligibleRemaining.length);
				const next = eligibleRemaining.splice(index, 1)[0];
				remainingStates = eligibleRemaining;
				currentState = next;
				questionCount += 1;
				questionCountEl.textContent = questionCount;
				if (mode === "choice") {
					promptEl.textContent =
						quizType === "capital"
							? "Which capital is highlighted?"
							: `Which ${regionLabel()} is highlighted?`;
					stateLabelEl.hidden = true;
					stateLabelEl.style.display = "none";
					stateLabelButton.textContent = "";
				} else {
					promptEl.textContent = "";
					stateLabelButton.textContent =
						quizType === "capital"
							? currentState.properties.capital
							: currentState.properties.name;
					stateLabelEl.hidden = false;
					stateLabelEl.style.display = "flex";
				}
				renderChoices();
				setInteraction(true);

				mapSvg
					.selectAll("path")
					.classed(
						"highlight",
						(d) => mode === "choice" && quizType === "state" && d === currentState
					);

				if (capitalsLayer) {
					capitalsLayer.style(
						"display",
						quizType === "capital" && mode === "choice" ? "block" : "none"
					);
					capitalsLayer
						.selectAll("circle")
						.classed(
							"active",
							(d) =>
								quizType === "capital" &&
								mode === "choice" &&
								d.state === currentState
						);
				}
			};

			const checkAnswer = (selected) => {
				if (!currentState) return;
				if (isLocked) return;
				setInteraction(false);
				const userAnswer = normalize(selected || "");
				const correctAnswer = normalize(getAnswerLabel(currentState));
				const targetPath = mapSvg
					.selectAll("path")
					.filter((d) => d === currentState);
				const targetCapital =
					quizType === "capital"
						? capitalsLayer
							?.selectAll("circle")
							.filter((d) => d.state === currentState)
						: null;

				if (userAnswer === correctAnswer) {
					score += 1;
					scoreEl.textContent = score;
					feedbackEl.textContent = "Correct!";
					targetPath.classed("correct", true).classed("wrong", false);
					targetCapital?.classed("correct", true).classed("wrong", false);
					setTimeout(() => pickNextState(), 700);
				} else {
					feedbackEl.textContent =
						quizType === "capital"
							? `Not quite — it was ${currentState.properties.capital} (${currentState.properties.name}).`
							: `Not quite — it was ${currentState.properties.name}.`;
					targetPath.classed("wrong", true).classed("correct", false);
					targetCapital?.classed("wrong", true).classed("correct", false);
					setTimeout(() => pickNextState(), 900);
				}
			};

			const checkMapAnswer = (clickedState) => {
				if (!currentState) return;
				if (isLocked || mode !== "click") return;
				setInteraction(false);
				const clickedName = clickedState.properties.name;
				const correctName = currentState.properties.name;
				const targetPath = mapSvg
					.selectAll("path")
					.filter((d) => d === currentState);
				const targetCapital =
					quizType === "capital"
						? capitalsLayer
							?.selectAll("circle")
							.filter((d) => d.state === currentState)
						: null;

				if (clickedState === currentState) {
					score += 1;
					scoreEl.textContent = score;
					feedbackEl.textContent = "Correct!";
					targetPath.classed("correct", true).classed("wrong", false);
					targetCapital?.classed("correct", true).classed("wrong", false);
					setTimeout(() => pickNextState(), 700);
				} else {
					feedbackEl.textContent =
						quizType === "capital"
							? `Wrong — you clicked ${clickedName}. It was ${correctName} (capital ${currentState.properties.capital}).`
							: `Wrong — you clicked ${clickedName}. It was ${correctName}.`;
					targetPath.classed("wrong", true).classed("correct", false);
					targetCapital?.classed("wrong", true).classed("correct", false);
					setTimeout(() => pickNextState(), 900);
				}
			};


			const buildMap = (features, projection) => {
				const path = d3.geoPath(projection);

				mapSvg.selectAll("*").remove();
				capitalsLayer = null;

				remainingStates = [...features];
				states = features;

				mapSvg
					.append("g")
					.attr("class", "states")
					.selectAll("path")
					.data(states)
					.join("path")
					.attr("d", path)
					.attr("aria-label", (d) => d.properties.name)
					.on("click", (event, d) => checkMapAnswer(d));

				const capitalPoints = states
					.map((state) => {
						if (!state.properties.capitalCoords) return null;
						const projected = projection(state.properties.capitalCoords);
						if (!projected) return null;
						return { state, coords: projected };
					})
					.filter(Boolean);

				if (capitalPoints.length) {
					capitalsLayer = mapSvg.append("g").attr("class", "capitals");
					capitalsLayer
						.selectAll("circle")
						.data(capitalPoints)
						.join("circle")
						.attr("r", 4)
						.attr("cx", (d) => d.coords[0])
						.attr("cy", (d) => d.coords[1]);
				}

				pickNextState();
			};

			const loadRegionData = () => {
				promptEl.textContent = "Loading map…";
				if (region === "us") {
					fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json")
						.then((response) => response.json())
						.then((topology) => {
							const geoData = topojson.feature(
								topology,
								topology.objects.states
							);
							const projection = d3.geoAlbersUsa().fitSize(
								[975, 610],
								geoData
							);

							const features = geoData.features
								.map((feature) => {
									const fips = String(feature.id).padStart(2, "0");
									const stateName = fipsToName[fips] || "Unknown";
									const capitalInfo = capitalByState[stateName];
									return {
										...feature,
										properties: {
											...feature.properties,
											name: stateName,
											capital: capitalInfo?.capital || null,
											capitalCoords: capitalInfo
												? [capitalInfo.lon, capitalInfo.lat]
												: null
										}
									};
								})
								.filter((feature) => feature.properties.name !== "Unknown");

							buildMap(features, projection);
						})
						.catch(() => {
							promptEl.textContent = "Failed to load map data.";
						});
					return;
				}

				fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json")
					.then((response) => response.json())
					.then((topology) => {
						const geoData = topojson.feature(
							topology,
							topology.objects.countries
						);
						const europeFeatures = geoData.features
							.map((feature) => {
								const name = feature.properties?.name || "";
								const capitalInfo = europeCapitalByCountry[name];
								return {
									...feature,
									properties: {
										...feature.properties,
										name,
										capital: capitalInfo?.capital || null,
										capitalCoords: capitalInfo
											? [capitalInfo.lon, capitalInfo.lat]
											: null
									}
								};
							})
							.filter((feature) => isEuropeCountry(feature.properties.name))
							.map(filterOverseasFrance)
							.map(filterSvalbard)
							.map(filterToEuropeBounds)
							.filter(Boolean);

						const projection = d3.geoMercator().fitSize(
							[975, 610],
							{ type: "FeatureCollection", features: europeFeatures }
						);

						buildMap(europeFeatures, projection);
					})
					.catch(() => {
						promptEl.textContent = "Failed to load map data.";
					});
			};

			quizStateBtn.addEventListener("click", () => setQuizType("state"));
			quizCapitalBtn.addEventListener("click", () => setQuizType("capital"));
			modeChoiceBtn.addEventListener("click", () => setMode("choice"));
			modeClickBtn.addEventListener("click", () => setMode("click"));
			regionUsBtn.addEventListener("click", () => setRegion("us"));
			regionEuBtn.addEventListener("click", () => setRegion("eu"));

			loadRegionData();
		</script>
	</body>
</html>
